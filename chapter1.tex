\newpage

\chapter{\textsc{огляд технології FHE}}


\section{Визначення}
В цій секції описана термінологія, яка використовується в дослідженнях FHE. Деякі з 
визначень були взяті напряму з документів FHE, інші були перефразовані для того, щоб
спростити формальність і зробити їх більш застосованими до обраної задачі.

Нехай є простір вхідного (чистого) тексту \(\mathcal{P}=\{0,1\}\), та сімейства функцій
\(F={f_1,f_2,...,f_n}\) де \(f_n(x) = f(x_1,x_2,x_3,...,x_k)\) це Булеві функції k
аргументів: \(f: P^n \rightarrow P\). Ми будемо називати F, сімейством Булевих схем
(Boolean circuit) \(C\), і використовувати звичайний запис функції \(C(m_1,m_2,...,m_n)\),
для позначення оцінки Булевої схеми на кортежі \((m_1,m_2,...,m_n)\).

\begin{definition}[\(\mathcal{C}\)-схема розрахунків, або ж просто \(\mathcal{C}\)-схема \cite{cryptoeprint:2011/344}] 
    Нехай \(\mathcal{C}\) це множина Булевих схем, тоді \(\mathcal{C}\)-схема розрахунків, для
    \(\mathcal{C}\) це набір функцій \((\textsc{gen, enc, eval, dec})\) які задовільняють наступним твердженням:


\(\textsc{\textbf{gen}}(1^\lambda,\alpha)\) - алгоритм генерації ключів, на вхід він приймає,
параметр шифрування \(\lambda\), та допоміжний параметр \(\alpha\). Результат виконання
алгоритму це триплет ключів \((pk,sk,evk)\), де ключ \(pk\) використовується для шифрування,
\(sk\) для дешифрування, та  \(evk\) для виконування розрахунків.

\(\textsc{\textbf{enc}}(pk,m)\) - алгоритм шифрування, на вхід він приймає ключ шифрування \(pk\) та
фрагмент не зашифрованого (чистого) тексту \(m\). Результат виконання алгоритму це шифр \(c\).

\(\textsc{\textbf{eval}}(evk,C,c_1,c_2...,c_n)\) - алгоритм розрахунків. На вхід він отримує,
ключ розрахунків \(evl\) та Булеву схему \(C \in \mathcal{C}\), та вхідні аргументи, які
можуть бути як шифром, так і результатом виконання минулих розрахунків. Результат виконання
алгоритму це результат виконання розрахунків.

\(\textsc{\textbf{dec}}(sk, c)\) - алгоритм дешифрування. На вхід приймає, ключ дешифрування
\(sk\), та шифр, або результат виконання розрахунків. Результат виконання алгоритму це не
зашифрований (чистий) текст \(m\).
\end{definition}

Для подальшого опису властивостей, треба визначити простори даних, які є результатами, або
вхідними параметрами описаних алгоритмів:

Нехай \(\mathcal{X}\) буде описувати простір \emph{чистого шифру}, \(\mathcal{Y}\) -
простір результатів виконання розрахунків, і \(\mathcal{Z} = \mathcal{X} \cup \mathcal{Y}\).
\(\mathcal{Z^*}\) - містить кортежі довільної довжини, які складаються
з елементів \(\mathcal{Z}\). Простори ключів згенерованих \textsc{\textbf{gen}},
позначимо як \(\mathcal{K}_p,\mathcal{K}_s,\mathcal{K}_e\) для \(pk,sk,evk\) відповідно.Алгоритм \textsc{\textbf{gen}} приймає на вхід параметр в унарній нотації \(1^\lambda\)
та опціональний допоміжний параметр \(\lambda\) з простору \(\mathcal{A}\). Також,
\(\mathcal{C}\) містить простір \emph{дозволених} булевих схем, а \(\mathcal{P}\), як було
зазначено раніше, область вхідного \emph{чистого (незашифрованого)тексту}.

Тепер можна описати область роботи наведених вище алгоритмів:
\begin{center}
    \begin{tabular}{l}
        \textsc{\textbf{gen }}: 
        \begin{math}
            \mathbb{N}\ \times\ \mathcal{A}\ \rightarrow\ 
            \mathcal{K}_p\ \times\ \mathcal{K}_s\ \times \ \mathcal{K}_e
        \end{math}\\

        \textsc{\textbf{enc }}:
        \begin{math}
            \mathcal{K}_p\ \times\ \mathcal{P}\ \rightarrow\ \mathcal{X}
        \end{math}\\

        \textsc{\textbf{eval}}:
        \begin{math}
            \mathcal{K}_e\ \times\ \mathcal{C}\ \times\ \mathcal{Z}^*\ 
            \rightarrow\ \mathcal{Y}
        \end{math}\\

        \textsc{\textbf{dec }}:
        \begin{math}
            \mathcal{K}_s\ \times\ \mathcal{Z}\ \rightarrow\ \mathcal{P}
        \end{math}
    \end{tabular}
\end{center}

Тоді \(\mathcal{X}\) та \(\mathcal{Y}\) можна визначити наступним чином:
\begin{center}
    \begin{math}
        \mathcal{X}\ =\ \{c\ |\ \textsc{\textbf{enc}}(pk,m)\ =\ c,\ m\ \in\ \mathcal{P}\}
    \end{math}
    \begin{math}
        \mathcal{Y}\ =\ \{z\ |\ \textsc{\textbf{eval}}(evk,C,c_1,c_2,...,c_n) = z,\ c_i\ \in\ 
        \mathcal{Z},\ C\ \in\ \mathcal{C} \}
    \end{math}
\end{center}
В деяких схемах, ключі розрахунків та шифрування однакові, але часто це і не так, тому в
визначеннях було наведено більш спільний випадок.

В оригінальних документах FHE \cite{cryptoeprint:2011/344} не було зазначено, що алгоритм
розшифровування \textsc{\textbf{dec}} повинен мати можливість працювати з результатом виконання
алгоритму шифрування \textsc{\textbf{enc}} - \(\mathcal{X}\), і було зазначено, що данні
можуть бути розшифровані після виконання розрахунків над ними \textsc{\textbf{eval}} - 
\(\mathcal{Y}\). Для можливості розшифровування, зразу після зашифровування було запропоновано
мати \emph{чисту Булеву схему} або ж по суті функцію \(f(x)=x\), для виконання розрахунків і
отримання даних які вже можна буде розшифровувати. Більшість сучасних FHE схем, дозволяють
проводити операції дешифрування даних, над якими не було проведено розрахунків, тому я не буду
заглиблюватись в цю тему.

\subsection{Атрибути та властивості}
Тут представлені характеристики методів гомоморфного шифрування. Ми встановлюємо такі
властивості, як компактність і конфіденційність схеми, які забороняють спрощені рішення
задачі гомоморфного шифрування, з одного боку, і вимагають таких властивостей, як
коректність, для того, щоб навіть називати це схемою шифрування.

\begin{definition}[Коректне розшифровування \cite{cryptoeprint:2015/1192}]
\label{def:corr-dec}
\(\mathcal{C}\)-схама має атрибут коректного розшифрування якщо виконується наступне твердження:
\begin{center}    
    \begin{math}
        \textsc{\textbf{dec}}(sk,\textsc{\textbf{enc}}(pk,m)) = m
    \end{math},\\
    де \(pk,sk,evk \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\), \(m \in \mathcal{P}\).
\end{center}
Це означає, що ми повинні мати можливість безпомилково розшифровувати зашифрований текст.
\end{definition}

\begin{definition}[Коректні розрахунки \cite{cryptoeprint:2015/1192}]
\label{def:corr-eval}
\(\mathcal{C}\)-схема коректно розраховує всі Булеві схеми \(C \in \mathcal{C}\), якщо
виконується наступне твердження:
    \begin{center}
        \begin{math}
        \textsc{\textbf{dec}}(sk,\textsc{\textbf{eval}}(evk,C,c_1,c_2,...,c_n))\ 
        =\ C(m_1,m_2,...m_n)
        \end{math},\\
        \(pk,sk,evk \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\), \(c_i \in \mathcal{X}\) та \(m_i \leftarrow \textsc{\textbf{dec}}(sk,c_i)\)
    \end{center}
Це визначення означає, що розрахунки над зашифрованими даними з подальшим
розшифровуванням повинні бути однакові з результатом розрахунків над не зашифрованими
даними.
\end{definition}

Будемо називати \(\mathcal{C}\)-схему \emph{коректною} якщо для неї будуть виконуватись
\ref{def:corr-dec} та \ref{def:corr-eval} твердження.

\begin{definition}[Компактність \(\mathcal{C}\)-схеми]
\label{def:compactness}
    \(\mathcal{C}\)-схема вважається компактною якщо існує поліном \(p\), такий що, для
    будь-якого кортежу \((pk,sk,evk) \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\), будь-якої Булевої схеми \(C \in \mathcal{C}\) та
    шифру \(c_i \in \mathcal{X}\), розмір результату виконання
    \(\textsc{\textbf{eval}}(evk,C,c_1,c_2,...,c_n)\) не більше від \(p(\lambda)\)
    бітів, в не залежності від Булевої схеми.
\end{definition}
Визначення \ref{def:compactness}, показує що під час гомоморфних операцій розмір
результату не повинен збільшуватись, і залежить тільки від параметра безпеки \(\lambda\).

\begin{definition}[Компактно розрахункова \(\mathcal{C}\)-схема \cite{homenc}]
\label{def:compactl-eval}
\(\mathcal{C}\)-схема компактно розраховує всі Булеві схема \(C \in \mathcal{C}\), якщо
вона компактна \ref{def:compactness} та \emph{коректна}.
\end{definition}

\subsubsection*{Безпека схеми}
Далі, важливо зупинитись на безпеці та конфіденційності схеми. Безпеку схеми можна
розділити на дві компоненти: семантична безпека, та обфускація схеми. Якщо обфускація
використовується коли алгоритм шифрування секретний, і вразливий, то семантична безпека
описує розподіл вихідних даних з \textsc{\textbf{eval}} та \textsc{\textbf{enc}}.
\begin{definition}[Приватне гомоморфне шифрування схеми \cite{homenc}(2.16)]
    \(\mathcal{C}\)-схема вважається безпечною, якщо для будь-якого кортежу \((pk,sk,evk) \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\), будь-якої Булевої схеми \(C \in \mathcal{C}\) та
    шифру \(c_i \in \mathcal{X}\), такого що \(m_i \leftarrow \textsc{\textbf{dec}}(sk, c_i)\) існує два розподіли:

\begin{center}
    \begin{math}
        Dist_1 = \textsc{\textbf{eval}}(evk,C,c_1,c_2,...,c_n)
    \end{math}\\
    \begin{math}
        Dist_2 = \textsc{\textbf{enc}}(pk,C(c_1,c_2,...,c_n)
    \end{math}
\end{center}
які повинні бути статистично або обчислювально нерозрізнені. Ці вимоги показують,
що розподіл виконання обчислень Булевої схеми над шифром \(Dist_1\) повинен бути однаковий (статистично, обчислювально) з розподілом, отриманим шляхом зашифровування
\emph{чистого} тексту, який насамперед являється результатом виконання Булевої операції 
над незашифрованими даними \(Dist_2\).

Часто термін безпечної системи можна зустріти як \emph{Сильно гомоморфна система}\cite{Clear_2013}. 
\end{definition}

\subsection{Класифікація}
Оскільки не всі схеми FHE мають однакові властивості, цей розділ показує як схеми
класифікуються, в залежності від того, які схеми вони можуть обчислювати.

\begin{definition}[Частково Гомоморфна схема або \(\mathcal{C}\)-Гомоморфізм \cite{cryptoeprint:2011/344}]
\(\mathcal{C}\)-схема називається, частково гомоморфною (SHE), якщо вона має коректне
шифрування \ref{def:corr-dec}, та коректне обчислення \ref{def:corr-eval}.
\end{definition}
Для частково гомоморфних \(\mathcal{C}\)-схем нема вимог до компактності, тому з кожним
гомоморфним розрахунком розмір вихідного шифру може збільшуватись. Також нема ніяких
вимог до множини Булевих операцій які можуть бути використовувані для розрахунків.

\begin{definition}[Обмежено-рівнева Гомоморфна схема]
\(\mathcal{C}\)-схема називається Обмежено-рівневою, якщо алгоритм генерації ключів
\textsc{\textbf{gen}} приймає додатковий параметр \(\alpha=d\), який означає максимальну
глибину Булевої схеми, яка може бути обчислена. Також застосовані вимоги до компактності,
коректності, і те що розмір вихідних даних розрахунків не повинен залежати від d.

\end{definition}

\begin{definition}[Повна Гомоморфна схема]
Повною гомоморфною схемою, називають \(\mathcal{C}\)-схему, до якої застосовані вимоги,
коректності, компактності, та вона може обчислювати Булеву схему з множини усіх схем, або
ж будь-яку схему.
\end{definition}

\subsection{Композиція розрахунків}
Часто, задача потребує декілька послідовних розрахунків, тобто результат певної Булевої
схеми повинен слугувати вхідними даними для наступної схеми, або ж простими словами
можна це назвати - композиція.
Кожну операцію розрахунків над шифром \textsc{\textbf{eval}} будемо називати \emph{етапом розрахунків}. 

З визначення коректних розрахунків \ref{def:corr-eval} видно що вхідні дані для
алгоритму обчислення \textsc{\textbf{eval}} повинні належати множині \(\mathcal{X}\) -
або ж множині \emph{чистого шифру}, який є результатом алгоритму \textsc{\textbf{enc}}.
Цей розділ описує вимоги, виконуючи які алгоритм розрахунку схеми \textsc{\textbf{eval}},
може приймати на вхід як результат виконання інших розрахунків \(\mathcal{Z}\), так і
\emph{чистий шифр} \(\mathcal{X}\): 

\(\textsc{\textbf{eval}}(evk, C, c_1,c_2,...,c_n)\),
де \((pk,sk,evk) \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\), \(C \in \mathcal{C}\) та \(c_i \in \mathcal{X} \cup \mathcal{Z}\)

В літературі \emph{розрахунки з етапами} називають \textbf{\emph{гомоморфним шифруванням
з i-етапами}}(i-hop homomorphic encryption \cite{10.1007/978-3-642-19571-6_14},
\cite{cryptoeprint:2010/145})

\begin{definition}[Розрахунки з етапами]
\label{def:stage-eval} 
    Обчислення \(\textbf{C}_{i,n}\) в \(i\) етапів, та шириною \(n\), визначається множиною
    Булевих схем \(\{C_{kl}\}\), де \(1 \leq k \leq i,1 \leq l \leq
    \) n, та \(C_{kl}\) має \(kn\) вхідних даних. За вхідними даними \(m_{01},m_{02},...,m_{0n}\) ми
    обчислюємо:
\begin{center}
    \(m_{kl} = C_{kl}(m_{01},m_{02},...,m_{0n},...,m_{k-1,1},...,m_{k-1,n})\), де \(1 \leq k \leq i,1 \leq l \leq n\).
\end{center}
Результат розрахунків з етапом після \textsc{\textbf{eval}} та \textsc{\textbf{dec}} буде 
\emph{чистий текст} \(m_{i1},m_{i2},...,m_{in}\). Визначимо початковий \emph{чистий текст} як
\(\overrightarrow{m_0}\), та вихідний \emph{чистий текст} як \(\overrightarrow{m_i}\), тоді можна
записати співвідношення \(\overrightarrow{m_i} = C_{i,n}(\overrightarrow{m_0})\).


Нехай \((pk,sk,evk) \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\),
та \(c_{i1},c_{i2},...,c_{in} \in \mathcal{X}\), тоді шифр \(\{c_{kl}\}\), 
\(1 \leq k \leq i,1 \leq l \leq n\) обчислюється рекурсивно наступним чином:
\begin{center}
    \(c_{kl} = \textsc{\textbf{eval}}(evk,C_{kl},c_{01},...,c_{0n},...,c_{k-1,1},...,c_{k-1,n})\)
\end{center}
Результат розрахунків з етапом над зашифрованими даними, буде шифр \(c_{i1},c_{i2},...,c_{in}\).
Позначивши початковий (вхідний) шифр як \(\overrightarrow{c_0}\) та результівний шифр як 
\(\overrightarrow{c_i}\) можна описати співвідношення яке описує нотацію алгоритму \textsc{\textbf{eval}}
з декількома виходами: \(\overrightarrow{c_i} = \textsc{\textbf{eval}}(evk,C_{1,n},\overrightarrow{c_0})\)
\end{definition}

\begin{figure}[ht!]
    \includegraphics[]{static/I-hop-eval.png}
    \caption{Приклад \cite{cryptoeprint:2015/1192} гомоморфного шифрування з i-етапами,
    де \(i=2,n=2\)}
    \label{fig:i-hop-eval}
\end{figure}

З вище описаного визначення \ref{def:stage-eval} можна зробити висновок що вхідними даними для
будь-якого етапу, окрім першого, може бути \textsc{тільки} результат попереднього етапу.

На перший погляд, може здатись, що якщо у нас є можливість обчислити довільну Булеву схему, не
використовуючи \(i\)-етапне шифрування, то повинна бути можливість обчислювати багато схем
послідовно. Проте це не так. Нема гарантій того, що результат виконання \textsc{\textbf{eval}},
буде валідний для використання як вхідні дані для наступного \textsc{\textbf{eval}}.
Наведемо приклад \cite{cryptoeprint:2015/1192}: Нехай у нас є схема \(C\) яка приймає на вхід
\(c_1,c_0,...,c_n\), та результатом якої є \(c'_0,c'_1,...,c'_v\), та схема \(C'\), яка приймає
на вхід \(c_0,c_1,...,c_v\) та результат якої \(c'_0,c'_1,...,c'_w\). Тоді існує 2 можливих 
сценарії: 1) Якщо ми візьмемо композицію \(C\) та \(C'\) як схему для розрахунків
\textsc{\textbf{eval}}(evk, \(C \circ C'\), \(c_1,c_2,...,c_n\)) то ці розрахунки будуть
коректними, оскільки виконується одна Булева схема, 2) проте, якщо ми спочатку розрахуємо
\textsc{\textbf{eval}}(evk, \(C\), \(c_1,c_2,...,c_n\)) = \(c'_1,c'_2,...,c'_v\), а потім
\textsc{\textbf{eval}}(evk, \(C'\), \(c'_1,c'_2,...,c'_v\)) то це не спрацює зі звичайною
схемою повного гомоморфного шифрування, оскільки вона не гарантує коректність даних після
розрахунків, для наступних операцій. Тому якщо стоїть задача виконання послідовних, незалежних
обчислень, то варто використовувати схему з i-етапами.

\begin{definition}[Коректність гомоморфного шифрування з i-етапами]
\label{def:i-hop-eval-corr}
Нехай \((pk,sk,evk) \leftarrow \textsc{\textbf{gen}}(1^\lambda,\alpha)\), \(\alpha \in \mathcal{A}\),
та \(\textbf{C}_{i,n}=\{C_{k,l}\}\) - довільне поетапне обчислення, де \(n\) це розмір
полінома від \(\lambda\) та \(\overrightarrow{c_0}=(c_{01},c_{02},...,c_{0n}) \in
\mathcal{X}^n\). Тоді \(\mathcal{C}\)-схему можна вважати коректною з і-етапами, якщо
виконується наступне твердження:
\begin{center}
    \begin{math}
        \textsc{\textbf{dec}}(sk,\textsc{\textbf{eval}}(evk,\textbf{C}_{i,n},
        \overrightarrow{c_0})) = \textbf{C}_{i,n}(\textsc{\textbf{dec}}(sk,\overrightarrow{c_0}))
    \end{math}
\end{center}
\end{definition}
Хоча це визначення і дуже схоже на визначення коректності розрахунків \ref{def:corr-eval},
проте важливо розуміти, що наведене вище визначення застосоване до розрахунків з
багатьма етапами, про що свідчить \(\textbf{C}_{i,n}\) = \(\{C_{k,l}\}\).


На Рис. \ref{fig:i-hop-eval} зображений приклад розрахунків з етапами, де \(i=2,n=2\).

Тепер, маючи загальне визначення коректності гомоморфного шифрування, можна описати більш
часткові випадки шифрування з i-етапами, а саме: i-етапне, мульті-етапне, полі-етапне та
\(\infty\)-етапне.

\begin{definition}[i-етапна \(\mathcal{C}\)-схема \cite{cryptoeprint:2010/145}]
    Нехай \(i \in \mathbb{N}\), тоді \(\mathcal{C}\)-схема \(i\)-етапна, якщо вона
    коректна для всіх \(j\)-етапних схем, де \(1 \leq j \leq i\).
\end{definition}

Замість того щоб параметризувати етапи числом, як в визначенні i-етапної схеми: \(i \in 
\mathbb{N}\), етапи можуть залeжaти від полінома параметризовані \(\lambda\).

\begin{definition}[мульті-етапна \(\mathcal{C}\)-схема \cite{cryptoeprint:2010/145}]
    Нехай \(p\) - деякий поліном, тоді \(\mathcal{C}\)-схема називається мульті-етапною,
якщо вона коректна для всіх \(j\)-етапних схем, таких  що: \(1 \leq j \leq p(\lambda)\).
\end{definition}

\begin{definition}[полі-етапна \(\mathcal{C}\)-схема \cite{cryptoeprint:2015/1192}]
    Нехай \(p\) - деякий поліном, та \(\alpha \in \mathcal{A}\), тоді 
    \(\mathcal{C}\)-схема називається полі-етапною, якщо вона коректна для 
    всіх \(j\)-етапних схема, таких  що: \(1 \leq j \leq p(\lambda, \alpha)\).
\end{definition}

\begin{definition}[\(\infty\)-етапнa \(\mathcal{C}\)-схема]
    \(\mathcal{C}\)-схема називається \(\infty\)-етапною, якщо вона коректна для всіх \(j\)-етапних схем для всіх j.
\end{definition}

\subsection{Зв'язок FHE та i-етапних схем}
todo

\section{Обмеження}
Існує велика кількість програм які використовують FHE для вирішування поставленої задачі. Проте
наразі існую обмеження у використання цієї технології, далі в цьому розділі буде розглянуто 
декілька з них. 

\begin{itemize}
    \item Перше обмеження FHE, це жорстка прив'язка пар ключів, що унеможливлює багатьом користувачам використовувати спільні дані. Уявимо ситуацію де багато
користувачів використовують систему яка, в свою чергу покладається на внутрішню базу 
даних для обчислень. Дані, які були додані в базу даних, можуть бути використані в
обчисленнях, тільки користувачем який їх туди додав. Тобто в ситуації коли багато 
користувачів повинні працювати над одними даними, щоб досягти спільної цілі - FHE 
обмежений. Проте існує гарний претендент на вирішення цього обмеження \cite{cryptoeprint:2013/094} Multikey Fully Homomorphic Encryption.

    \item Друге обмеження це те що FHE потребує дуже великих витрат на обчислення.
Розрахунки та проведення операцій над зашифрованими даними виконуються набагато довше ніж
на чистих незашифрованих даних. Хоча сучасні алгоритми FHE показують достойні 
покращення в часі на розрахунки, однак ця проблема все ще залишається одним із головних
аргументів не використовувати FHE. Запропоноване часткове розв'язання цієї проблеми, це 
використовувати Тьюрінг Машини замість Булевих схем \cite{10.1007/978-3-642-40084-1_30}.

    \item Третє обмеження 

\end{itemize}

\section{Відомі області застосування}
