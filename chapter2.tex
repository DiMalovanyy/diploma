\newpage

\chapter{\textsc{Використання FHE в хмарних технологіях}}

\section{Бібліотека HeLib}
Для реалізації поставленої задачі буде використовуватись бібліотека гомоморфного шифрування
HeLib. HeLib була написана на С++ та реалізовує функціонал  Brakerski-Gentry-Vaikuntanathan 
(BGV), та Cheon-Kim-Kim-Song (CKKS) схем.

З середини 2018 року HElib знаходиться на стадії інтенсивного рефакторінгу для підвищення
надійності, розширяємості, продуктивності та, найголовніше, легкості у використанні для дослідників та розробників, які працюють з HE та його застосуванням.

Нижче представлені деякі ключові аспекти того, як HElib реалізує схему FHE:
\begin{itemize}
\item{\textsc{\textbf{Шифрування на основі поліномів}}: HElib використовує схему
    шифрування на основі поліномів, де відкриті текстові повідомлення 
    (\emph{чистий текст}) подаються у вигляді поліномів над скінченним полем. 
    Процес шифрування полягає у перетворенні текстового повідомлення у поліном, а потім у
    застосуванні до нього деяких математичних операцій.}

\item{\textsc{\textbf{Генерація ключів}}: HElib генерує набір ключів, необхідних для
    шифрування, розшифрування та гомоморфних операцій. Ці ключі включають секретний ключ,
    відкритий ключ та розрахункові ключі. Секретний ключ зберігається у таємниці, тоді як
    відкритий ключ надається стороні, яка виконує обчислення. Розрахункові ключі
    використовуються для виконання гомоморфних операцій над зашифрованими даними.} 

\item{\textsc{\textbf{Шифрування}}: Щоб зашифрувати відкрите повідомлення, HElib перетворює
    його у поліном і застосовує операції шифрування з використанням відкритого ключа. Цей
    процес включає додавання шумового члена до полінома для забезпечення безпеки.}

\item{\textsc{\textbf{Гомоморфні операції}}: HElib підтримує різні гомоморфні операції,
    такі як додавання, множення та обертання. Ці операції дозволяють виконувати обчислення
    над зашифрованими даними без їх розшифрування. Для виконання цих операцій HElib
    використовує математичні методи, такі як поліноміальне множення та модулярна арифметика.}

\item{\textsc{\textbf{Розшифрування}}: Щоб розшифрувати результат обчислень, HElib
    використовує секретний ключ і застосовує операції дешифрування. Шумовий член, доданий
    під час шифрування, зменшується під час розшифрування, щоб отримати вихідне
    повідомлення у відкритому вигляді.}

\item{\textsc{\textbf{Оптимізація продуктивності}}: HElib включає декілька оптимізацій
    продуктивності для підвищення ефективності обчислень FHE. Ці оптимізації включають такі
    методи, як перемикання модулів, завантаження та пакування декількох значень відкритого
    тексту в один зашифрований текст.}
\end{itemize}

\subsection{Алгоритми над схемою}
\begin{itemize}
\item{\textsc{\textbf{Гомоморфне додавання:}}
    Гомоморфне додавання дозволяє додавати два поліноми зашифрованого тексту, в результаті
    чого виходить новий поліном зашифрованого тексту, що представляє собою суму відповідних
    поліномів відкритого тексту.

    Процес гомоморфного додавання полягає у додаванні коефіцієнтів поліномів зашифрованого
    тексту за модулем скінченного поля. Математично, для двох поліномів шифрованого тексту
    \(C_1(x)\) і \(C_2(x)\), що представляють поліноми відкритого тексту \(P_1(x)\) і 
    \(P_2(x)\) відповідно:
    \begin{math}
        C_1(x) + C_2(x) = (P_1(x) + P_2(x))\ mod\ q
    \end{math}, де \(q\) - модуль скінченного поля.

    Оскільки додавання є простою операцією, то додавання поліномів зашифрованого тексту
    можна виконувати безпосередньо, член за членом, без необхідності розшифровувати
    поліноми. Ця властивість дозволяє проводити обчислення над зашифрованими даними без
    розкриття оригінального відкритого тексту.
}
\item{\textsc{\textbf{Гомоморфне множення:}}
    Гомоморфне множення дозволяє перемножити два поліноми зашифрованого тексту, в
    результаті чого новий поліном зашифрованого тексту є добутком відповідних поліномів
    відкритого тексту.

    Процес гомоморфного множення є більш складним і вимагає додаткових кроків:
    \begin{enumerate}
        \item{\textbf{Перемноження}:
            Для множення двох поліномів зашифрованого тексту виконується операція множення
            поліномів. Ця операція передбачає множення коефіцієнтів поліномів разом, член
            за членом. Результуючий поліном являє собою поточковий добуток поліномів
        відкритого тексту.}
        \item{\textbf{Зведення до спільного степеню за модулем}:
            Після множення многочленів, результуючий многочлен може мати більш високі
            степені через процес множення. Щоб зберегти цілісність схеми шифрування,
            отриманий поліном потрібно зменшити по модулю на певний коефіцієнт. Цей множник
            часто пов'язаний з модулем q скінченного поля.}
        \item{\textbf{Обмін ключами}: 
            Для продовження виконання гомоморфних операцій над отриманим поліномом
            застосовується процес, який називається \emph{обмін ключів}. Обмін ключів
            дозволяє перетворити ключ шифрування, який використовувався під час шифрування,
        на ключ розрахунків, що дає змогу продовжити гомоморфні обчислення.}
    \end{enumerate}
}
\item{\textsc{\textbf{Гомоморфне обертання:}}
    Гомоморфне обертання дозволяє зміщувати коефіцієнти полінома зашифрованого тексту, тим
    самим змінюючи порядок даних у поліноміальному поданні. Ця операція особливо корисна
    для виконання операцій над підмножинами даних або перестановки полінома відповідно до
    бажаних обчислень.

    Для досягнення гомоморфного обертання можна використовувати різні методи, такі як
    операції модулярної арифметики, матриці перестановок або інші специфічні для шифрування
    методи. Ці методи дозволяють ефективно зміщувати коефіцієнти, зберігаючи при цьому
    властивості шифрування.
}

\end{itemize}
Важливо відзначити, що гомоморфні операції вносять шум і можуть впливати на безпеку і
точність обчислень. У міру виконання операцій шумовий член накопичується і може вимагати
додаткових кроків, наприклад застосування описаної раніше техніки повторного шифрування,
щоб зберегти безпеку і правильність обчислень.

Використовуючи гомоморфне додавання, множення і обертання, обчислення можна виконувати над
зашифрованими даними без їх розшифровки, що дозволяє проводити обчислення з дотриманням
конфіденційності, зберігаючи при цьому конфіденційність відкритих текстових
повідомлень.

\section{Реалізація застосунку}
Для демонстрації коректності роботи, та можливості застосування FHE схеми у хмарних 
технологіях, був реалізований клієнт-серверний застосунок. Застосунок повинен реалізовувати
логіку банківської системи, тобто клієнт повинен мати можливість створити рахунок,
додати баланс, та зняти баланс з рахунку. Окрім цього, система бути розроблена з розрахунком
на те що вона буде знаходитись на хмарі, та між клієнтом і хмарою буде незахищене з'єднання.
Також, користувач банківського сервісу хоче бути впевнений в повному захисті даних, в тому
числі від сервера. Для реалізації вимог для безпеки даних буде використана FHE з реалізацією
BGV схеми в бібліотеці HeLib. Див. Рис 2.1.

\begin{figure}[!ht]
    \centering
    \includegraphics{static/client-server-logic.png}
    \caption{Демонстрація запитів клієнтів до серверу, де перервана стрілочка, означає
    незахищене середовище, тому данні в ньому будуть зашифровані}
    \label{fig:client-server-logic}
\end{figure}

\subsection{Вимоги}
Ця секція описує вимоги до розробки банківської системи, яка повинна забезпечувати коректність,
та безпеку даних.
\subsubsection*{Клієнт}
Основна задача клієнта, це створити необхідний контекст для FHE шифрування, ініціювати
з'єднання з сервером, робити необхідні запити, та обробляти відповіді від сервера.

Як було написано вище, клієнт повинен бути відповідальний за створення контексту шифрування. Під
контекстом, будемо вважати необхідні дані для правильного працювання FHE, зашифровування та розшифровування даних.
Деяку частину контекста необхідно буде надати серверу для того, щоб він мав можливість виконувати
розрахунки над зашифрованими даними, проте частина контекста повинна бути нерозголошуєма, така як
приватний ключ.

Контекст буде зберігатись на машині клієнта у файлі Json формату, і при ініціюванні з'єднання
з сервером, у клієнта повинна бути можливість вибору, чи створювати новий контекст, чи використати
присутній.

Нехай контекст був згенерований з деякими тестовими параметрами тоді його Json, та приватний
ключ буде виглядати наступним чином:

\begin{lstlisting}[breaklines, caption={Json репрезентація, контексу, деякі довгі послідовносиі чисел були замінені на трикрапку, щоб зменшити кількість тексту}, 
captionpos=b]
{"HElibVersion":"2.2.0","content":{"alsoThick":false,"build_cache":false,"digits":[[6,"..."],[11,"..."]],"ePrime_param":4,"e_param":12,"gens":[2341,3277,911],"hwt_param":120,"m":4095,"mvec":[7,"..."],"ords":[6,4,6],"p":2,"qs":[249047285761,"..."],"r":1,"scale":10.0,"smallPrimes":[0,"..."],"specialPrimes":[15,"..."],"stdev":{"exponent":0,"mantissa":3.2}},"serializationVersion":"0.0.1","type":"Context"}
\end{lstlisting}

\begin{lstlisting}[breaklines, caption={Json репрезентація приватного ключа}, captionpos=b]
{"HElibVersion":"2.2.0","content":{"b":[{"map":[[ large amount of 64-bits integers]],"set":[6,7,...]}]},"serializationVersion":"0.0.1","type":"SecKey"}
\end{lstlisting}
Клієнт повинен правильно серіалізувати свій контекст, для подальшого відправлення серверу,
та приватний ключ, для зберігання.

\begin{lstlisting}[breaklines, caption={Json формат зберігання приватного контексту на 
клієнті, для можливості його подальшого використання}, captionpos=b]
{
    "public_context": "Listing 2.1",
    "private_key": "Listing 2.2"
}
\end{lstlisting}

\subsubsection*{Сервер}
Задача серверної частини застосунку, це приймати TCP/IP з'єднання, та коректно обробляти 
запити від клієнта. Окрім глобальної задачі сервера, він повинен виконувати якусь логіку.

Також для зручного використання на хмарі, сервер повинен мати інструмент автоматичної розгортки,
для цього буде використана технологія контейнеризації Docker.

Фактично, логіку серверу можна поділити на 2 частини:
\begin{itemize}
    \item{\textbf{Пошук сутності в зашифрованій базі даних}: Хоча задача пошуку даних в базі
даних, може здатись тривіальною задачею, коли сервер працює повністю над зашифрованими даними,
задача стає дещо складнішою, оскільки шифрування одних і тих самих даних, може давати різний
результат кожен раз, тому просте зіставлення з даними в базі не дасть коректного результату.

Для коректного знаходження даних в базі, за ключем буде використовуватись наступний алгоритм:

Нехай у нас є сховище ключ-значення Рис. 2.2.


\begin{figure}[!ht]
    \centering
    \label{fig:key-value-storage}
    \includegraphics[scale=1.25]{static/key-value-storage.png}
    \caption{Де \(K\)- це множина ключів, та \(k_1,k_2,...,k_n \in K\), \(v_1, v_2,...,v_n 
    \in V\), де \(V\)- це множина значень, а \(n\)-кількість сутностей в базі. Тобто
    відображення \(K \rightarrow V\) є бієктивним.}
\end{figure}

    Високорівнево, алгоритм пошуку в базі, над зашифрованими даними описаний на заображенні
    Рис. 2.3.

\begin{figure}[!ht]
    \label{fig:basic-value-extraction}
    \includegraphics[scale=0.85]{static/basic-value-extraction.png} 
    \caption{Спрощений алгоритм пошука значення \(V_x \in V\), за ключем \(K_x \in K\)}
\end{figure}

    Далі буде описано більш детально алгоритм пошуку за ключем в зашифрованій базі даних.
    
    Першим кроком алгоритму є обчислення операції різниці між запитом і ключами бази даних. Це
    проста операція віднімання, яка поелементно виконує віднімання у структурі, схожій на масив. В
    результаті буде отримано різницевий шифротекст, який ми позначимо як \(\Delta_i\) де
\(\Delta_1,\Delta_2,...,\Delta_n \in \delta\). Наразі 
    \(\Delta = 0\) якщо \(k_q \in K\), і ненульовому значенню в іншому випадку, див. Рис. 2.4.

\begin{figure}[!ht]
    \centering
    \label{fig:key-subsruction}
    \includegraphics[scale=1.25]{static/key-substruction.png}
    \caption{Віднімання ключів, щоб отримати \(\Delta_1,\Delta_2,...,\Delta_n \in \delta\).
    Де у випадку \(K_q \in K\, \Delta_q = 0, \Delta_i \neq 0, i \neq q\)}.
\end{figure}


Це не зовсім та маска, яка нам потрібна, тому ми повинні виконати іншу операцію, описану далі.
Для отримання правильної маски, треба буде застосувати малу теорему Фермa  \cite{Fermat} до
\(\Delta_i \in \delta\). Застосувавши теорему, ми отримаємо наступний результат:

\begin{align*}
\text{LTF}(\Delta_i) =
\begin{cases} 
    1, & \Delta_i \neq 0 \\
    0, & \Delta_i = 0
\end{cases}
\end{align*}

Проте, ця маска дає обернений результат, щоб отримати коректні значення, треба застосувати
операцію інверсії:

\begin{align*}
1- \text{LTF}(\Delta_i) =
\begin{cases} 
    0, & \Delta_i \neq 0 \\
    1, & \Delta_i = 0
\end{cases}
\end{align*}

Якщо описати процес знаходження над зашифрованими даними \textsc{\textbf{enc}}(\(x\)), то це
буде виглядати так, як зображено на Рис. 2.5.

Спочатку ми застосовуємо операцію малої теореми Ферма (FLT) \cite{Fermat} до кожного різницевого
зашифрованого тексту. Це призводить до шифрування нуля, \(E(0)\), якщо різниця дорівнює нулю,
тобто є збіг, і шифрування одиниці, \(E(1)\), в іншому випадку.

Далі ми використовуємо попередньо обчислені результати операції FLT і віднімаємо це значення від
1. Це значення 1 може бути чистим, оскільки будь-яка операція між зашифрованим текстом і
відкритим текстом призводить до зашифрованого тексту. Це призводить до відображення будь-якого
ненульового значення в нуль і нуля в одиницю. Таким чином, ми отримуємо маски, які нам потрібні
для алгоритму порівняння. 

Однак є ще один аспект, який слід взяти до уваги, а саме: як ми повинні діяти з частковими збігами?

\begin{figure}[!ht]
    \centering
    \label{fig:mask-creation-flow}
    \includegraphics[scale=1.25]{static/mask-creation-flow.png}
    \caption{Процес створення правильної маски над зашифрованими даними}
\end{figure}
Розглянемо наступний сценарій, показаний на зображенні нижче Рис 2.6. Уявіть, що ключ збігається лише з
другою літерою запиту і, можливо, з деякими значеннями пропусків, тоді він створить масив, як
показано нижче Рис. 2.6.

Оскільки в нашому прикладі нас цікавлять лише точні збіги, цей результат слід вважати таким, що
не збігається. Щоб усунути часткові збіги, ми просто копіюємо зашифрований текст, виконуємо
обертання структури масиву в копії і перемножуємо його за входом з оригінальною копією. Це
означає, що якщо в одному з осередків зашифрованого тексту є хоча б один 0, то цей осередок
ефективно обнулить всі інші осередки масиву.

Зауважте, що оскільки ми не можемо знати, який саме шифротекст містить результат, що збігається,
частково збігається або не збігається, ця операція також виконується над результатом, що
збігається. Однак, оскільки у зашифрованому тексті у кожному слоті має бути 1, то ця операція не
повинна мати ніякого ефекту.

\begin{figure}[!ht]
    \centering
    \label{fig:partial-match}
    \includegraphics{static/partial-match.png}
    \caption{Частковий збіг, який не повинен вважатись коректним}
\end{figure}

Тепер, коли ми маємо остаточні маски, ми можемо виконати вилучення даних з бази даних. Цей крок
передбачає множення маски на відповідний запис у базі даних. Оскільки наша маска є шифруванням 0,
якщо немає збігу, множення її на відповідний запис обнулить цей запис. Крім того, оскільки маска
є шифруванням 1, якщо є збіг, множення її на запис поверне сам запис. 

Оскільки ключі в нашому прикладі бази даних є унікальними, можна бути впевненим, що на кожен
запит буде отримано максимум один унікальний збіг. Використовуючи ці знання, можна об'єднати всі
результати кроку вилучення значень в один зашифрований текст. Це пов'язано з тим, що додавання
шифрів 0 до значення не змінює саме значення. Це дозволяє економити на зв'язку, оскільки серверу
потрібно надсилати клієнту лише один зашифрований текст, а не по одному зашифрованому тексту для
кожного запису в базі даних.

}
    \item{\textbf{Виконання розрахунків над зашифрованими даними}:}
\end{itemize}


\subsubsection*{Комунікація клієнту з сервером (API)}
Клієнт повинен мати можливість комунікувати з сервером і робити запит на операції: створити
новий рахунок, зняти баланс з рахунку, додати баланс на рахунок, та отримати інформацію
про кількість грошей на рахунку. Окрім цього, для деяких операцій, клієнт повинен надати
серверу деякі дані, наприклад під час створення рахунку, клієнт повинен відправити FHE контекст
для того, щоб сервер міг правильно працювати з цими даними в майбутньому.

Для спрощення імплементації, клієнт буде відправляти та отримувати дані в форматі Json, в
якому буде міститись поле про тип операції (create, get, add, withdraw) в полі 
request (запит), та необхідну інформацію в полі body (тіло).

Також як було описано в Ліст. 2.1. клієнт відповідальний за відправку FHE контексту шифрування,
щоб забезпечити можливість серверу коректно працювати з даними клієнта. Важливо зазначити, що
цей контекст не дає можливість розшифровувати данні.

\subsection{Стек технологій для розробки}
Для реалізації банківської системи був вибраний наступний стек технологій:
\begin{itemize}

    \item{Мова розробки була вибрана: C++, так як реалізація FHE схем краще всього написана
на ній і показують достойну швидкість обчислення}
    \item{Для реалізації FHE буде використана бібліотека з відкритим кодом HeLib, з
якої буде взята логіка BGV схеми}
    \item{Для TCP/IP з'єднання між клієнтом та сервером (хмарою) буде використана бібліотека
з колекції Boost: Asio, яка дозволяє виконувати асинхронні операції з IO девайсами, в тому
числі в ній знаходиться функціонал для реалізації TCP/IP з'єднань.}
    \item{Для більш зручної розробки будуть використані сторонні бібліотеки та інструменти:
логування, збірка проєкту, тестування, засоби вимірювання швидкодії.}
\end{itemize}

\subsection{Результати роботи застосунку}


