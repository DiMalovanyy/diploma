\newpage

\chapter{\textsc{Використання FHE в хмарних технологіях}}

\section{Бібліотека HeLib}
Для реалізації поставленої задачі буде використовуватись бібліотека гомоморфного шифрування
HeLib. HeLib була написана на С++ та реалізовує функціонал  Brakerski-Gentry-Vaikuntanathan 
(BGV), та Cheon-Kim-Kim-Song (CKKS) схем.

З середини 2018 року HElib знаходиться на стадії інтенсивного рефакторінгу для підвищення
надійності, розширяємості, продуктивності та, найголовніше, легкості у використанні для дослідників та розробників, які працюють з HE та його застосуванням.

Нижче представлені деякі ключові аспекти того, як HElib реалізує схему FHE:
\begin{itemize}
\item{\textsc{\textbf{Шифрування на основі поліномів}}: HElib використовує схему
    шифрування на основі поліномів, де відкриті текстові повідомлення 
    (\emph{чистий текст}) подаються у вигляді поліномів над скінченним полем. 
    Процес шифрування полягає у перетворенні текстового повідомлення у поліном, а потім у
    застосуванні до нього деяких математичних операцій.}

\item{\textsc{\textbf{Генерація ключів}}: HElib генерує набір ключів, необхідних для
    шифрування, розшифрування та гомоморфних операцій. Ці ключі включають секретний ключ,
    відкритий ключ та розрахункові ключі. Секретний ключ зберігається у таємниці, тоді як
    відкритий ключ надається стороні, яка виконує обчислення. Розрахункові ключі
    використовуються для виконання гомоморфних операцій над зашифрованими даними.} 

\item{\textsc{\textbf{Шифрування}}: Щоб зашифрувати відкрите повідомлення, HElib перетворює
    його у поліном і застосовує операції шифрування з використанням відкритого ключа. Цей
    процес включає додавання шумового члена до полінома для забезпечення безпеки.}

\item{\textsc{\textbf{Гомоморфні операції}}: HElib підтримує різні гомоморфні операції,
    такі як додавання, множення та обертання. Ці операції дозволяють виконувати обчислення
    над зашифрованими даними без їх розшифрування. Для виконання цих операцій HElib
    використовує математичні методи, такі як поліноміальне множення та модулярна арифметика.}

\item{\textsc{\textbf{Розшифрування}}: Щоб розшифрувати результат обчислень, HElib
    використовує секретний ключ і застосовує операції дешифрування. Шумовий член, доданий
    під час шифрування, зменшується під час розшифрування, щоб отримати вихідне
    повідомлення у відкритому вигляді.}

\item{\textsc{\textbf{Оптимізація продуктивності}}: HElib включає декілька оптимізацій
    продуктивності для підвищення ефективності обчислень FHE. Ці оптимізації включають такі
    методи, як перемикання модулів, завантаження та пакування декількох значень відкритого
    тексту в один зашифрований текст.}
\end{itemize}

\subsection{Алгоритми над схемою}
\begin{itemize}
\item{\textsc{\textbf{Гомоморфне додавання:}}
    Гомоморфне додавання дозволяє додавати два поліноми зашифрованого тексту, в результаті
    чого виходить новий поліном зашифрованого тексту, що представляє собою суму відповідних
    поліномів відкритого тексту.

    Процес гомоморфного додавання полягає у додаванні коефіцієнтів поліномів зашифрованого
    тексту за модулем скінченного поля. Математично, для двох поліномів шифрованого тексту
    \(C_1(x)\) і \(C_2(x)\), що представляють поліноми відкритого тексту \(P_1(x)\) і 
    \(P_2(x)\) відповідно:
    \begin{math}
        C_1(x) + C_2(x) = (P_1(x) + P_2(x))\ mod\ q
    \end{math}, де \(q\) - модуль скінченного поля.

    Оскільки додавання є простою операцією, то додавання поліномів зашифрованого тексту
    можна виконувати безпосередньо, член за членом, без необхідності розшифровувати
    поліноми. Ця властивість дозволяє проводити обчислення над зашифрованими даними без
    розкриття оригінального відкритого тексту.
}
\item{\textsc{\textbf{Гомоморфне множення:}}
    Гомоморфне множення дозволяє перемножити два поліноми зашифрованого тексту, в
    результаті чого новий поліном зашифрованого тексту є добутком відповідних поліномів
    відкритого тексту.

    Процес гомоморфного множення є більш складним і вимагає додаткових кроків:
    \begin{enumerate}
        \item{\textbf{Перемноження}:
            Для множення двох поліномів зашифрованого тексту виконується операція множення
            поліномів. Ця операція передбачає множення коефіцієнтів поліномів разом, член
            за членом. Результуючий поліном являє собою поточковий добуток поліномів
        відкритого тексту.}
        \item{\textbf{Зведення до спільного степеню за модулем}:
            Після множення многочленів, результуючий многочлен може мати більш високі
            степені через процес множення. Щоб зберегти цілісність схеми шифрування,
            отриманий поліном потрібно зменшити по модулю на певний коефіцієнт. Цей множник
            часто пов'язаний з модулем q скінченного поля.}
        \item{\textbf{Обмін ключами}: 
            Для продовження виконання гомоморфних операцій над отриманим поліномом
            застосовується процес, який називається \emph{обмін ключів}. Обмін ключів
            дозволяє перетворити ключ шифрування, який використовувався під час шифрування,
        на ключ розрахунків, що дає змогу продовжити гомоморфні обчислення.}
    \end{enumerate}
}
\item{\textsc{\textbf{Гомоморфне обертання:}}
    Гомоморфне обертання дозволяє зміщувати коефіцієнти полінома зашифрованого тексту, тим
    самим змінюючи порядок даних у поліноміальному поданні. Ця операція особливо корисна
    для виконання операцій над підмножинами даних або перестановки полінома відповідно до
    бажаних обчислень.

    Для досягнення гомоморфного обертання можна використовувати різні методи, такі як
    операції модулярної арифметики, матриці перестановок або інші специфічні для шифрування
    методи. Ці методи дозволяють ефективно зміщувати коефіцієнти, зберігаючи при цьому
    властивості шифрування.
}

\end{itemize}
Важливо відзначити, що гомоморфні операції вносять шум і можуть впливати на безпеку і
точність обчислень. У міру виконання операцій шумовий член накопичується і може вимагати
додаткових кроків, наприклад застосування описаної раніше техніки повторного шифрування,
щоб зберегти безпеку і правильність обчислень.

Використовуючи гомоморфне додавання, множення і обертання, обчислення можна виконувати над
зашифрованими даними без їх розшифровки, що дозволяє проводити обчислення з дотриманням
конфіденційності, зберігаючи при цьому конфіденційність відкритих текстових
повідомлень.

\section{Реалізація застосунку}
Для демонстрації коректності роботи, та можливості застосування FHE схеми у хмарних 
технологіях, був реалізований клієнт-серверний застосунок. Застосунок повинен реалізовувати
логіку банківської системи, тобто клієнт повинен мати можливість створити рахунок,
додати баланс, та зняти баланс з рахунку. Окрім цього, система бути розроблена з розрахунком
на те що вона буде знаходитись на хмарі, та між клієнтом і хмарою буде незахищене з'єднання.
Також, користувач банківського сервісу хоче бути впевнений в повному захисті даних, в тому
числі від сервера. Для реалізації вимог для безпеки даних буде використана FHE з реалізацією
BGV схеми в бібліотеці HeLib. Див. Рис 2.1.

\begin{figure}[!ht]
    \centering
    \includegraphics{static/client-server-logic.png}
    \caption{Демонстрація запитів клієнтів до серверу, де перервана стрілочка, означає
    незахищене середовище, тому данні в ньому будуть зашифровані}
    \label{fig:client-server-logic}
\end{figure}

\subsection{Вимоги}
Ця секція описує вимоги до розробки банківської системи, яка повинна забезпечувати коректність,
та безпеку даних.
\subsubsection*{Клієнт}
Основна задача клієнта, це створити необхідний контекст для FHE шифрування, ініціювати
з'єднання з сервером, робити необхідні запити, та обробляти відповіді від сервера.

Як було написано вище, клієнт повинен бути відповідальний за створення контексту шифрування. Під
контекстом, будемо вважати необхідні дані для правильного працювання FHE, зашифровування та розшифровування даних.
Деяку частину контекста необхідно буде надати серверу для того, щоб він мав можливість виконувати
розрахунки над зашифрованими даними, проте частина контекста повинна бути нерозголошуєма, така як
приватний ключ.

Контекст буде зберігатись на машині клієнта у файлі Json формату, і при ініціюванні з'єднання
з сервером, у клієнта повинна бути можливість вибору, чи створювати новий контекст, чи використати
присутній.

Нехай контекст був згенерований з деякими тестовими параметрами тоді його Json, та приватний
ключ буде виглядати наступним чином:

\begin{lstlisting}[breaklines, caption={Json репрезентація, контексу, деякі довгі послідовносиі чисел були замінені на трикрапку, щоб зменшити кількість тексту}, 
captionpos=b]
{"HElibVersion":"2.2.0","content":{"alsoThick":false,"build_cache":false,"digits":[[6,"..."],[11,"..."]],"ePrime_param":4,"e_param":12,"gens":[2341,3277,911],"hwt_param":120,"m":4095,"mvec":[7,"..."],"ords":[6,4,6],"p":2,"qs":[249047285761,"..."],"r":1,"scale":10.0,"smallPrimes":[0,"..."],"specialPrimes":[15,"..."],"stdev":{"exponent":0,"mantissa":3.2}},"serializationVersion":"0.0.1","type":"Context"}
\end{lstlisting}

\begin{lstlisting}[breaklines, caption={Json репрезентація приватного ключа}, captionpos=b]
{"HElibVersion":"2.2.0","content":{"b":[{"map":[[ large amount of 64-bits integers]],"set":[6,7,...]}]},"serializationVersion":"0.0.1","type":"SecKey"}
\end{lstlisting}
Клієнт повинен правильно серіалізувати свій контекст, для подальшого відправлення серверу,
та приватний ключ, для зберігання.

\begin{lstlisting}[breaklines, caption={Json формат зберігання приватного контексту на 
клієнті, для можливості його подальшого використання}, captionpos=b]
{
    "public_context": "Listing 2.1",
    "private_key": "Listing 2.2"
}
\end{lstlisting}

Для того щоб клієнт мав можливість перевикористовувати створений ним контекст, був
розроблений додатковий скрипт, який зберігає публічний та приватний контекст в файл.
Клієнт при ініціюванні з'єднання з сервером моє можливість вибрати файл з контекстами,
або ж використати новий (згенерований).

\subsubsection*{Сервер}
Задача серверної частини застосунку, це приймати TCP/IP з'єднання, та коректно обробляти 
запити від клієнта. Окрім глобальної задачі сервера, він повинен виконувати якусь логіку.

Також для зручного використання на хмарі, сервер повинен мати інструмент автоматичної розгортки,
для цього буде використана технологія контейнеризації Docker.

Фактично, логіку серверу можна поділити на 2 частини:
\begin{itemize}
    \item{\textbf{Пошук сутності в зашифрованій базі даних}: Хоча задача пошуку даних в базі
даних, може здатись тривіальною задачею, коли сервер працює повністю над зашифрованими даними,
задача стає дещо складнішою, оскільки шифрування одних і тих самих даних, може давати різний
результат кожен раз, тому просте зіставлення з даними в базі не дасть коректного результату.

Для коректного знаходження даних в базі, за ключем буде використовуватись наступний алгоритм:

Нехай у нас є сховище ключ-значення Рис. 2.2.


\begin{figure}[!ht]
    \centering
    \label{fig:key-value-storage}
    \includegraphics[scale=1.25]{static/key-value-storage.png}
    \caption{Де \(K\)- це множина ключів, та \(k_1,k_2,...,k_n \in K\), \(v_1, v_2,...,v_n 
    \in V\), де \(V\)- це множина значень, а \(n\)-кількість сутностей в базі. Тобто
    відображення \(K \rightarrow V\) є бієктивним.}
\end{figure}

    Високорівнево, алгоритм пошуку в базі, над зашифрованими даними описаний на заображенні
    Рис. 2.3.

\begin{figure}[!ht]
    \label{fig:basic-value-extraction}
    \includegraphics[scale=0.85]{static/basic-value-extraction.png} 
    \caption{Спрощений алгоритм пошука значення \(V_x \in V\), за ключем \(K_x \in K\)}
\end{figure}

    Далі буде описано більш детально алгоритм пошуку за ключем в зашифрованій базі даних.
    
    Першим кроком алгоритму є обчислення операції різниці між запитом і ключами бази даних. Це
    проста операція віднімання, яка поелементно виконує віднімання у структурі, схожій на масив. В
    результаті буде отримано різницевий шифротекст, який ми позначимо як \(\Delta_i\) де
\(\Delta_1,\Delta_2,...,\Delta_n \in \delta\). Наразі 
    \(\Delta = 0\) якщо \(k_q \in K\), і ненульовому значенню в іншому випадку, див. Рис. 2.4.

\begin{figure}[!ht]
    \centering
    \label{fig:key-subsruction}
    \includegraphics[scale=1.25]{static/key-substruction.png}
    \caption{Віднімання ключів, щоб отримати \(\Delta_1,\Delta_2,...,\Delta_n \in \delta\).
    Де у випадку \(K_q \in K\, \Delta_q = 0, \Delta_i \neq 0, i \neq q\)}.
\end{figure}


Це не зовсім та маска, яка нам потрібна, тому ми повинні виконати іншу операцію, описану далі.
Для отримання правильної маски, треба буде застосувати малу теорему Фермa  \cite{Fermat} до
\(\Delta_i \in \delta\). Застосувавши теорему, ми отримаємо наступний результат:

\begin{align*}
\text{LTF}(\Delta_i) =
\begin{cases} 
    1, & \Delta_i \neq 0 \\
    0, & \Delta_i = 0
\end{cases}
\end{align*}

Проте, ця маска дає обернений результат, щоб отримати коректні значення, треба застосувати
операцію інверсії:

\begin{align*}
1- \text{LTF}(\Delta_i) =
\begin{cases} 
    0, & \Delta_i \neq 0 \\
    1, & \Delta_i = 0
\end{cases}
\end{align*}

Якщо описати процес знаходження над зашифрованими даними \textsc{\textbf{enc}}(\(x\)), то це
буде виглядати так, як зображено на Рис. 2.5.

Спочатку ми застосовуємо операцію малої теореми Ферма (FLT) \cite{Fermat} до кожного різницевого
зашифрованого тексту. Це призводить до шифрування нуля, \(E(0)\), якщо різниця дорівнює нулю,
тобто є збіг, і шифрування одиниці, \(E(1)\), в іншому випадку.

Далі ми використовуємо попередньо обчислені результати операції FLT і віднімаємо це значення від
1. Це значення 1 може бути чистим, оскільки будь-яка операція між зашифрованим текстом і
відкритим текстом призводить до зашифрованого тексту. Це призводить до відображення будь-якого
ненульового значення в нуль і нуля в одиницю. Таким чином, ми отримуємо маски, які нам потрібні
для алгоритму порівняння. 

Однак є ще один аспект, який слід взяти до уваги, а саме: як ми повинні діяти з частковими збігами?

\begin{figure}[!ht]
    \centering
    \label{fig:mask-creation-flow}
    \includegraphics[scale=1.25]{static/mask-creation-flow.png}
    \caption{Процес створення правильної маски над зашифрованими даними}
\end{figure}
Розглянемо наступний сценарій, показаний на зображенні нижче Рис 2.6. Уявіть, що ключ збігається лише з
другою літерою запиту і, можливо, з деякими значеннями пропусків, тоді він створить масив, як
показано нижче Рис. 2.6.

Оскільки в нашому прикладі нас цікавлять лише точні збіги, цей результат слід вважати таким, що
не збігається. Щоб усунути часткові збіги, ми просто копіюємо зашифрований текст, виконуємо
обертання структури масиву в копії і перемножуємо його за входом з оригінальною копією. Це
означає, що якщо в одному з осередків зашифрованого тексту є хоча б один 0, то цей осередок
ефективно обнулить всі інші осередки масиву.

Зауважте, що оскільки ми не можемо знати, який саме шифротекст містить результат, що збігається,
частково збігається або не збігається, ця операція також виконується над результатом, що
збігається. Однак, оскільки у зашифрованому тексті у кожному слоті має бути 1, то ця операція не
повинна мати ніякого ефекту.

\begin{figure}[!ht]
    \centering
    \label{fig:partial-match}
    \includegraphics{static/partial-match.png}
    \caption{Частковий збіг, який не повинен вважатись коректним}
\end{figure}

Тепер, коли ми маємо остаточні маски, ми можемо виконати вилучення даних з бази даних. Цей крок
передбачає множення маски на відповідний запис у базі даних. Оскільки наша маска є шифруванням 0,
якщо немає збігу, множення її на відповідний запис обнулить цей запис. Крім того, оскільки маска
є шифруванням 1, якщо є збіг, множення її на запис поверне сам запис. 

Оскільки ключі в нашому прикладі бази даних є унікальними, можна бути впевненим, що на кожен
запит буде отримано максимум один унікальний збіг. Використовуючи ці знання, можна об'єднати всі
результати кроку вилучення значень в один зашифрований текст. Це пов'язано з тим, що додавання
шифрів 0 до значення не змінює саме значення. Це дозволяє економити на зв'язку, оскільки серверу
потрібно надсилати клієнту лише один зашифрований текст, а не по одному зашифрованому тексту для
кожного запису в базі даних.

Виникає питання: Чому просто не використовувати побайтне порівняння зашифрованого тексту, з
ключем? На те є 2 причини: перша і головна, це те що з цим алгоритмом, сервер не може 
знати чи існує такий ключ в його базі даних чи ні, він просто виконує алгоритм. Друге,
це те що контекст може змінитись, наприклад в результаті перешифрування (Визн. \ref{def:bootstraping}), в такому випадку побайтове порівняння не спрацює.

}
    \item{\textbf{Виконання розрахунків над зашифрованими даними}:
Кожен біт двійкового числа кодується в один шифрований текст. Таким чином, для 16-бітового
двійкового числа ми представимо його у вигляді масиву з 16 унікальних шифротекстів.

\begin{centering}
    \(b_0 = [0]\ [0]\ [0]\ ...\ [0]\ [0]\ [0]\)     \(\leftarrow\) шифр для біту 0\\
    \(b_1 = [1]\ [1]\ [1]\ ...\ [1]\ [1]\ [1]\)     \(\leftarrow\) шифр для біту 1\\
    \(b_2 = [1]\ [1]\ [1]\ ...\ [1]\ [1]\ [1]\)     \(\leftarrow\) шифр для біту 2\\
\end{centering}
 цей приклад показує шифр для 3-бітного числа 110b = 6.

 Клієнт повинен зашифровувати число (його бінарну репрезентацію) та відправляти на сервер,
 сервер повинен виконувати операцію над цим зашифрованим числом згідно з вимогами клієнта та
 перевіряти можливість виконання операції (наприклад що баланс не менше 0).
}
\end{itemize}


\subsubsection*{Комунікація клієнту з сервером (API)}
Клієнт повинен мати можливість комунікувати з сервером і робити запит на операції: створити
новий рахунок, зняти баланс з рахунку, додати баланс на рахунок, та отримати інформацію
про кількість грошей на рахунку. Окрім цього, для деяких операцій, клієнт повинен надати
серверу деякі дані, наприклад під час створення рахунку, клієнт повинен відправити FHE контекст
для того, щоб сервер міг правильно працювати з цими даними в майбутньому.

Для спрощення імплементації, клієнт буде відправляти та отримувати дані в форматі Json, в
якому буде міститись поле про тип операції (create, get, add, withdraw) в полі 
request (запит), та необхідну інформацію в полі body (тіло).

Також як було описано в Ліст. 2.1. клієнт відповідальний за відправку FHE контексту шифрування,
щоб забезпечити можливість серверу коректно працювати з даними клієнта. Важливо зазначити, що
цей контекст не дає можливість розшифровувати данні.

В кожному запиті клієнт повинен відправляти зашифровану назву акаунту, окрім цього в деяких
операціях необхідна додаткова інформація, наприклад для операцій add, та withdraw 
необхідна сума балансу для додавання/зняття.

\begin{lstlisting}[breaklines, caption={Json формат запиту клієнта до сервера}, captionpos=b]
{
    "operation: "add",
    "public_context": "Listing 2.1",
    "private_key": "Listing 2.2"
    "account_name": "FHE Encrypted data",
    "amount": "FHE Encrypted data"
}
\end{lstlisting}
Хоча запит виглядає і досить компактним, на практиці FHE потребує дуже багато ресурсів,
тому таке повідомлення буде мати розмір в середньому 6 мегабайт.

Для отримання відповіді сервер збирає повідомлення в залежності від того чи сталась помилка,
або все вібдбулось коректно. Наприклад повідомлення яке показує що акаунту не існує, або
те що баланс від'ємний, буде виглядати наступним чином:

\begin{lstlisting}[breaklines, caption={Json формат помилки клієнту від сервера}, captionpos=b]
{
    "operation: "get",
    "status": "error",
    "error_msg": "No access to account",
}
{
    "operation: "withdraw",
    "status": "error",
    "error_msg": "Impossible to withdraw: balance < 0",
}
\end{lstlisting}


\subsection{Стек технологій для розробки}
Для реалізації банківської системи був вибраний наступний стек технологій:
\begin{itemize}

    \item{Мова розробки була вибрана: C++, так як реалізація FHE схем краще всього написана
на ній і показують достойну швидкість обчислення}
    \item{Для реалізації FHE буде використана бібліотека з відкритим кодом HeLib, з
якої буде взята логіка BGV схеми}
    \item{Для TCP/IP з'єднання між клієнтом та сервером (хмарою) буде використана бібліотека
з колекції Boost: Asio, яка дозволяє виконувати асинхронні операції з IO девайсами, в тому
числі в ній знаходиться функціонал для реалізації TCP/IP з'єднань.}
    \item{Для більш зручної розробки будуть використані сторонні бібліотеки та інструменти:
логування, збірка проєкту, тестування, засоби вимірювання швидкодії.}
\end{itemize}

\subsection{Результати роботи застосунку}

Для коректної роботи з сервером, перш за все треба створити контекст шифрування, для
цього необхідно використати скрипт для генерації цього контексту:

\begin{spverbatim}[breaklines, caption={Команда генерації нового контексту шифрування},
captionpos=b]
$> ./code/diploma_code_utils --help
Usage: ./program p m r bits c mvec_size gen_size \
      ords_size output_file [mvec_elements] \
      [gens_elements] [ords_elements]

$> ./code/diploma_code_utils 131 4095 1 1000 2 4 3 3\
     out.context 7 5 9 13 2341 3277 911 6 4 6
\end{spverbatim}

Згенерує файл Json формата з контекстом та приватним ключем (Лістинг 2.3).

Сервер стандартно запускається на порті 7623
\begin{spverbatim}
> ./code/diploma_code_server
[2023-06-06 14:52:56.427] [debug] Сервер сконфігурований на порті: 7623
[2023-06-06 14:52:56.428] [debug] Сервер запущений
\end{spverbatim}

Для демонстрації покажемо створення акаунту \emph{test}, та додавання до нього балансу.
Клієнтський застосунок виглядає наступним чином:
\begin{spverbatim}
$> ./code/diploma_code_client
Використання: client [COMMAND] --context-path [FILE_PATH] [ARGUMENTS...]
Команди:
  get           Отримати інформацію про аккаунт
      Параметри: <Назва аккаунту>

  create        Створює новий аккаунт
      Параметри: <Назва аккаунту>

  add           Додати баланс на аккаунт
      Параметри: <Назва аккаунту> <Кількість балансу>

  withdraw      Зняти баланс з аккаунту
      Параметри: <Назва аккаунту> <Кількість балансу>
$> ./code/diploma_code_client create --context-path out.context test
[2023-06-06 15:02:00.028] [debug] Зчитування файлу конекста: out.context
[2023-06-06 15:02:00.726] [debug] Шифрування назви аккаунту...
[2023-06-06 15:02:00.730] [debug] Викликана команда create("test")
[2023-06-06 15:02:00.730] [client] [info] Обробка запиту для створення акаунту...
[2023-06-06 15:02:00.730] [client] [debug] З'єднання з сервером успішно встановлено. Відпрака запита на створення аккаунту...
[2023-06-06 15:02:00.820] [client] [debug] Успішно відправлено 4332480 байтів на сервер
[2023-06-06 15:02:01.576] [client] [debug] Успішно отримана відповідь від сервер: {"body":null,"status":"success"}
\end{spverbatim}

В той час на серері відбувається обробка запиту:
\begin{spverbatim}
...
[2023-06-06 15:02:00.730] [info] Нове з'єднання: 127.0.0.1:50661
[2023-06-06 15:02:00.837] [Client 127.0.0.1:50661] [debug] Отриманий запит від клієнта. Прочитано 4332480 байтів.
[2023-06-06 15:02:00.865] [info] Обробка запиту від клієнта. Запит: create
[2023-06-06 15:02:01.574] [Database] [debug] Контент успішно доданий в базу даних
[2023-06-06 15:02:01.575] [Client 127.0.0.1:50661] [info] Запит від клієнта успішно обролений
[2023-06-06 15:02:01.578] [Client 127.0.0.1:50661] [debug] Успішно відправлено 33 байтів клієнту
...
\end{spverbatim}
В цей час сервер оброблив запит, та зберіг результати в базі даних, а саме записав їх
в пам'ять, та файл який обслуговується сервером щоб зберігати інформацію. Окрім
зашифрованої назви акаунту, сервер також збергіає публічний контекст клієнта, щоб
у нього була можливість виконувати операції над даними, після перезапуску сервера.

Тепер покажемо операцію додавання балансу до існуючого акаунту. Звісно, щоб мати
можливість виконувати операції з існуючим акаунтом, та мати можливість розшифровувати
результат, нам необхідно використовувати той самий контекст:

\begin{spverbatim}
> ./code/diploma_code_client add --context-path out.context test 100
...
[2023-06-06 15:19:39.623] [debug] Викликана команда add("test1", 100)
...
[2023-06-06 15:20:18.478] [client] [debug] Успішно отримана відповідь від сервер: {"body":null,"status":"success"}
\end{spverbatim}

З отриманої відповіді від сервера можна побачити, що виконання гомоморфних операції, займає
дуже багато часу (майже 30 секунд).

Тепер щоб перевірити що баланс дійсно був доданий можна виконати операцію get, яка повинна 
повернути інформацію про аккаунт, також цей приклад показує, що клієнт має змогу
розшифровувати дані, змінені сервером:

\begin{spverbatim}
> ./code/diploma_code_client get --context-path out.context test
[2023-06-06 15:25:27.589] [debug] Зчитування файлу конекста: out.context
[2023-06-06 15:25:28.270] [debug] Шифрування назви аккаунту...
[2023-06-06 15:25:28.274] [debug] Викликана команда get("test1")
...
[2023-06-06 15:25:38.367] [client] [debug] Успішно відправлено 5132600 байтів на сервер
[2023-06-06 15:25:39.120] [client] [debug] Успішно отримана відповідь від сервер: {"body":
"довге зашифроване повідомлення","status":"success"}
[2023-06-06 15:25:42.410] [client] [info] Успішно розшифроване повідомлення від сервера.
> {"balance": 100}
\end{spverbatim}

Як ми бачимо, результат лише пошуку в базі, значно кращий аніж додаткова операція додавання,
це тому що, наш алгоритм шифрує кожен байт значення балансу, і додавання повинно
відбуватись також побайтно. Також тут видно, що операція розшифрування забирає також
якийсь час (3 секунди).

Якщо знайти оптимальні для нашої задачі параметри для створення контексту, то час
роботи системи може покращитись, не втрачаючи рівень безпеки.

